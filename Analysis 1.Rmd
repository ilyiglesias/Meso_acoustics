---
title: "Compare biomass between years"
output: html_notebook
---

# NOTES: 
II as of April 17th, I ran the code below, which ran smoothly, but did not go through it all line by line to ensure it is all clean and ready to go. I need to review this and write up methods concurrently. However, because I am meeting with Jerome on Friday and just took GAM class, I am going to hopscotch this section since it should be all worked out and good and move on to oceanographic variables and GAM, coming back to this later! Also need to look into global Moran's I
... June 2023: I am now back and going to run the following code and concurrently write up my results as I go (and work on a presentation for next week)
... July 2023: reviewing all of the output a final time as I write up a more finalized version of the Results section for our manuscript

### Analysis 1: Are there differences in biomass and CM between years?! 

### Background: 
The following code analyzes whether there were any differences in the biomass and center of mass depth (m) BETWEEN years in our study. The thought: in the warmer years 2015 and 2016, there appears to be higher overall biomass and a deeper center of mass depth compared to the other years of our study. However, because we originally exported our data in 100m fine-resolution cells, there is the question of which years are significant across years AND at varying cell sizes (sensitivity analysis)

At the finer-resolution, 100m cell size, there is spatially autocorrelation, so we run the risk of violating the assumptions of our statistical test-- everything comes out significant, probably because of the shear number of samples. ON the contrary, when we re-grid up to 25km, we loose a lot of the data. SO Jarrod's suggestion was to run the analysis with many different grid sizes (100m, 1km, 5km, 10km, 15km, 20km and 25km ) and just see if the results change! Results: from 10km onward, the results are totally consistent, so our decision to re-grid by 25km feels justified (could select cell sizes from 10km upward and it doesn't appear to change our results)

NOTE: 
- analysis part 1 (this document): Comparing differences in biomass and Center of mass depth between years
- analysis part 2 (Analysis 2.Rmd): which oceanographic variables are likely driving the center of mass depth of the DSL at a regridded distance of 25km

This code covers part 1: a comparison of biomass and center of mass between years

# Load libraries 
```{r load libraries}
library(tidyverse) # all things
library(lubridate) # dates
library(sf) # spatial features, mapping
library(multcompView) #cld compact letter display for output
library(rcompanion) # this just helps us complete the mult comp test output so it can be read by mulcompView
library(ggthemes) # simplification of themes for ggplotting
```

# Which re-grid size are you working on?!! MANUAL step
I regridded by 1km, 5km, 10km, 15km, 20km (from fine-resolution, 100m data originally output)
Need to set the dataset here (df are differentiated by grid size as acoustics_regrid_15km for ex) so the following code will all run on the same input (to avoid errors changing the df every grid cell size)
NOTE: All of the regridded data followed the exact same format. However, the 100m plots from echo_integration_all required some changing of terms (ie Lat_M instead of lat etc.) In some cases, for plotting purposes, I filtered out the -999 dB values from the 100m grid cells. This is not to say that they were not valid data! -999 dB on the log scale is just 0! But for plotting purposes it made it difficult to visualize
NOTE: update in June I am ignoring the 100m fine resolution cells for now, because I did it the first time (old data analysis) and we know these data are autocorelated- also they are annoying to work with because the don't follow the same format- but I've done it, just see old code if needed
```{r manually set the grid size we are working with }

# MANUAL step: select which regridding of acoustics data we are interested in
acoustic_regrid= acoustics_regrid_25km

grid_size="25km" #MANUAL step

```

### MINIMUM number of 100m grid cells to trust in larger grid size
There are some instances where our re-gridded cell (of whichever scale) were based on 1 or few 100m horizontal cells. Since we are extrapolating these values over a large region, it seems responsible to ensure that there were at least a minimum of 3 100m fine-resolution cells covering a larger grid cell

```{r}
# Ensure each cell has at least 3 100m grid cells per re-gridded cell (echo_count)

acoustic_regrid= acoustic_regrid |> 
                 filter(echo_count>=3)

```

# set up gridlines (regardless of regrid size) for plotting

```{r}

# gridlines-- to draw gridlines based on indivdiual gridcell size
#longitude (x axis)
lon1 <- unique(acoustic_regrid$lon_grid_low)
lon2<- unique(acoustic_regrid$lon_grid_hi)
# add on highest value from lon_grid_high
lon=unique(c(lon1, lon2))
lon
rm(lon1, lon2)

#latitude (y axis)
lat1 <- unique(acoustic_regrid$lat_grid_low)
lat2<- unique(acoustic_regrid$lat_grid_hi)
# add on highest value from lon_grid_high
lat=unique(c(lat1, lat2))
lat
rm(lat1, lat2)


```

# # PLOT acoustic track over regridded data-- how many fine-resolution cells per re-gridded cell?
Probably need to adjust the shape size depending on grid size ~4 is a nice size for 25km
can adjust size of square as needed

note that for 1km, it was too diffiuclt to see the acoustic track so I # it out as well as grid lines
#MANUAL: change cell size in geom_point
```{r}

# MANUAL: change the size in geom_point to fit grid cell size :)
ggplot()+
  geom_sf(data=states, fill="grey", color="black")+# plot state basemap
  geom_point(data = acoustic_regrid, aes(x= lon, y=lat, fill=MVBS), color="black", stroke=0, size=5.2, shape=22 )+ #plot regridded data
  geom_text(data=acoustic_regrid, aes(x=lon, y=lat, label=echo_count), size=2)+ #label # of 100m cells per re-grid cell
  geom_point(data=echo_integration_all, aes(x=Lon_M, y=Lat_M), size=0.01, color="grey", alpha=0.9)+ #overlay of cruise track over regridded data
  scale_fill_viridis_c(option = "D", direction=1)+ #color output via viridis
  coord_sf(xlim = c(min(acoustic_regrid$lon-0.25), max(acoustic_regrid$lon+0.25)), ylim = c(min(acoustic_regrid$lat-0.25), max(acoustic_regrid$lat+0.25)))+ 
  scale_x_continuous(breaks = lon, minor_breaks = NULL)+
  scale_y_continuous(breaks=lat, minor_breaks = NULL)+
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        panel.grid = element_line(colour = "black", linetype = "solid", linewidth =0.25),
        panel.background = element_blank())+
  labs(x="Longitude", y="Latitude", color = "MVBS")+ #legend
  facet_wrap(~year)
  
  
#Save plot
ggsave(filename=paste0("./plots/analysis 1/regrid_coverage_", grid_size, "_map.pdf"))
```
25km: size=5.2

# Calculate median values for plotting 
se=s/sqrt(n) where s= sample standard deviation and n=sample size. in our case, our units here are the # of grid cells per year
```{r}

# group by year and create summary stats such as median values and se and other labels for boxplot
summary_year <- acoustic_regrid  |> 
                group_by(year) |> 
                summarize(no_grid_cells=n(),
                          median_MVBS=round(median(MVBS), 2),
                          median_NASC=round(median(NASC), 5), 
                          median_CM=round(median(cm_m)),
                          se_MVBS=sd(MVBS)/sqrt(no_grid_cells),
                          se_NASC=sd(NASC)/sqrt(no_grid_cells),
                          se_CM=sd(cm_m)/sqrt(no_grid_cells),
                          sd_MVBS=sd(MVBS),
                          sd_NASC=sd(NASC),
                          sd_CM=sd(cm_m),
                          quantile_mvbs=quantile(MVBS, probs=0.75), #find the 3rd quantile for labeling letters later
                          quantile_cm=quantile(cm_m, probs=0.75)) 
```
I loaded the library plotrix which has the function std.error as a double check and all values the same so just going with sd()/sqrt(# grid cells)

# MVBS between years (boxplot)
The following is a box plot (with points shown) depicting MVBS values per year for our given grid cell size defined by 
```{r}

# simple box plot of MVBS values per year
ggplot(data=acoustic_regrid, aes(x=year, y=MVBS), color="black")+
  stat_boxplot(geom="errorbar", width=0.25)+
  geom_boxplot(data=acoustic_regrid, aes(x=year, y=MVBS, color=year), outlier.shape=NA, show.legend = FALSE)+ #plot boxplots without outliers since these are all plotted via geom_jitter
  scale_color_manual(values = c("2013"="grey20", "2014"="grey20", "2015"="chocolate", "2016"="chocolate", "2017"="grey20", "2018"="grey20"))+
  geom_jitter(alpha=0.2, color="snow4")+ #add actual data points to our boxplot
  geom_text(data= summary_year, aes(x = as.factor(year), y = median_MVBS, label = paste0("MVBS: ", median_MVBS)), size = 2.5, vjust = -1)+ #label median 
  geom_text(data= summary_year, aes(x = as.factor(year), y = median_MVBS, label = paste0("n: ", no_grid_cells)), size = 2, vjust = 1.5,color="black")+
  xlab("Year")+
  ylab("MVBS (dB)")+
  ggthemes::theme_few()


#save
ggsave(filename=paste0("./plots/analysis 1/boxplot_mvbs_", grid_size, ".pdf"), width=7, height=5, units="in")

```
# MVBS between years (boxplot) --- CLEAR background for presentations
```{r clear background}

ggplot(data=acoustic_regrid, aes(x=year, y=MVBS))+
  stat_boxplot(geom="errorbar", width=0.25, color="white")+
  geom_boxplot(data=acoustic_regrid, aes(x=year, y=MVBS, fill=year), outlier.shape=NA, show.legend = FALSE, color="white")+ #plot boxplots without outliers since these are all plotted via geom_jitter
  scale_fill_manual(values = c("2013"="grey20", "2014"="grey20", "2015"="chocolate", "2016"="chocolate", "2017"="grey20", "2018"="grey20"))+
  geom_jitter(alpha=0.2, color="snow4")+ #add actual data points to our boxplot
  geom_text(data= summary_year, aes(x = as.factor(year), y = median_MVBS, label = paste0("MVBS: ", median_MVBS)), size = 2.5, vjust = -1, color="white")+ #label median 
  geom_text(data= summary_year, aes(x = as.factor(year), y = median_MVBS, label = paste0("n: ", no_grid_cells)), size = 2, vjust = 1.5,color="white")+
  xlab("Year")+
  ylab("MVBS (dB)")+
  ggthemes::theme_few()+
theme(legend.position = 'none',
        panel.background = element_rect(fill = 'transparent', color="white"),
        plot.background = element_rect(fill='transparent', color="white"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.background = element_rect(fill='transparent'),
        legend.box.background=element_rect(fill = 'transparent'),
        axis.text = element_text(colour="white"),
        axis.line = element_line(color = "white"),
        axis.title = element_text(color="white"))



# save plot to plots folder
ggsave(filename=paste0("./plots/analysis 1/boxplot_mvbs_clear", grid_size, ".pdf"), width=7, height=5, units="in", bg="transparent")
```


# CM between years (boxplot)

```{r}
# simple box plot of NASC values
ggplot(data=acoustic_regrid, aes(x=year, y=cm_m, color=year))+
  stat_boxplot(geom="errorbar", width=0.25)+
  geom_boxplot(data=acoustic_regrid, aes(x=year, y=cm_m), outlier.shape=NA, show.legend = FALSE)+ #plot boxplots without outliers since in jitter
  scale_color_manual(values = c("2013"="grey20", "2014"="grey20", "2015"="chocolate", "2016"="chocolate", "2017"="grey20", "2018"="grey20"))+
  geom_jitter(alpha=0.1, color="slategrey")+ #add actual data points to our boxplot
  scale_y_reverse()+
  geom_text(data= summary_year, aes(x = as.factor(year), y = median_CM, label = paste0("CM: ", median_CM)), size = 2.5, vjust = -0.5)+ #label median 
  geom_text(data= summary_year, aes(x = as.factor(year), y = median_CM, label = paste0("n: ", no_grid_cells)), size = 2, vjust = 1.5, color="black")+ #label sample size 
  xlab("Year")+
  ylab("CM (m)")+
  ggthemes::theme_few()+
  theme(legend.position = 'none')

# save plot to plots folder
ggsave(filename=paste0("./plots/analysis 1/boxplot_cm_", grid_size, ".pdf"), width=7, height=5, units="in")
```
# CM between years-- clear background for presentation purpoes
White font and transparent background for better plotting
```{r clear background white text for ref}
ggplot(data=acoustic_regrid, aes(x=year, y=cm_m, fill=year))+
  stat_boxplot(geom="errorbar", width=0.25, color="white")+
  geom_boxplot(data=acoustic_regrid, aes(x=year, y=cm_m), outlier.shape=NA, show.legend = FALSE, color="white")+ #plot boxplots without outliers since in jitter
  scale_fill_manual(values = c("2013"="grey20", "2014"="grey20", "2015"="chocolate", "2016"="chocolate", "2017"="grey20", "2018"="grey20"))+
  geom_jitter(alpha=0.1, color="slategrey")+ #add actual data points to our boxplot
  scale_y_reverse()+
  geom_text(data= summary_year, aes(x = as.factor(year), y = median_CM, label = paste0("CM: ", median_CM)), size = 2.5, vjust = -0.5, color="white")+ #label median 
  geom_text(data= summary_year, aes(x = as.factor(year), y = median_CM, label = paste0("n: ", no_grid_cells)), size = 2, vjust = 1.5, color="white")+ #label sample size 
  xlab("Year")+
  ylab("CM (m)")+
  ggthemes::theme_few()+
  theme(legend.position = 'none',
        panel.background = element_rect(fill = 'transparent', color="white"),
        plot.background = element_rect(fill='transparent', color="white"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.background = element_rect(fill='transparent'),
        legend.box.background=element_rect(fill = 'transparent'),
        axis.text = element_text(colour="white"),
        axis.line = element_line(color = "white"),
        axis.title = element_text(color="white"))

# save plot to plots folder
ggsave(filename=paste0("./plots/analysis 1/boxplot_cm_clear", grid_size, ".pdf"), width=7, height=5, units="in", bg="transparent")
```


# PLOT: Distribution of MVBS between years

```{r}
# using binned output (25x25km)
ggplot(data = acoustic_regrid, aes(x=MVBS, colour=year))+
  #geom_histogram(aes(y=..density..),color="grey", fill="transparent", binwidth = 50)+ #this is plotting properly for some reason
  geom_density(alpha=0.2, fill="NA")+ #plot density curves
  scale_color_manual(values = c("2013"="grey86", "2014"="grey75", "2015"="chocolate", "2016"="darkorange", "2017"="grey50", "2018"="grey20"))+
  scale_x_continuous(expand=c(0,0))+ #move plot to axis
  scale_y_continuous(expand = c(0,0))+
  xlab("MVBS (dB) ")+
  theme_classic()

ggsave(paste0("./plots/analysis 1/mvbs_bw_years_", grid_size, ".pdf"))
```


Great little plot depicting the differences in the distribution of MVBS between years! 

# Plot the distribution of values between years -- CM 

```{r}
# using binned output (25x25km)
ggplot(data = acoustic_regrid, aes(x=cm_m, colour=year))+
  #geom_histogram(aes(y=..density..),color="grey", fill="transparent", binwidth = 50)+ #this is plotting properly for some reason
  geom_density(alpha=0.2, fill="NA")+ #plot density curves
  scale_color_manual(values = c("2013"="grey86", "2014"="grey75", "2015"="chocolate", "2016"="darkorange", "2017"="grey50", "2018"="grey20"))+
  scale_x_continuous(expand=c(0,0))+ #move plot to axis
  scale_y_continuous(expand = c(0,0))+
  xlab("Center of mass (m) ")+
  theme_classic()

ggsave(paste0("./plots/analysis 1/cm_bw_years_", grid_size, ".pdf"))
```

# Combined plot
The following is simply the two plots above combined into one output...
```{r}
library(patchwork)
p1=ggplot(data = acoustic_regrid, aes(x=MVBS, colour=year))+
  #geom_histogram(aes(y=..density..),color="grey", fill="transparent", binwidth = 50)+ #this is plotting properly for some reason
  geom_density(alpha=0.2, fill="NA", show.legend = F)+ #plot density curves
  scale_color_manual(values = c("2013"="grey86", "2014"="grey75", "2015"="chocolate", "2016"="darkorange", "2017"="grey50", "2018"="grey20"))+
  scale_x_continuous(expand=c(0,0))+ #move plot to axis
  scale_y_continuous(expand = c(0,0))+
  xlab("MVBS (dB) ")+
  theme_classic()
p2=ggplot(data = acoustic_regrid, aes(x=cm_m, colour=year))+
  #geom_histogram(aes(y=..density..),color="grey", fill="transparent", binwidth = 50)+ #this is plotting properly for some reason
  geom_density(alpha=0.2, fill="NA")+ #plot density curves
  scale_color_manual(values = c("2013"="grey86", "2014"="grey75", "2015"="chocolate", "2016"="darkorange", "2017"="grey50", "2018"="grey20"))+
  scale_x_continuous(expand=c(0,0))+ #move plot to axis
  scale_y_continuous(expand = c(0,0))+
  xlab("Center of mass (m) ")+
  theme_classic()

p1+p2
ggsave(paste0("./plots/analysis 1/cm_mvbs_dist_combo_", grid_size, ".pdf"), height=4, width=8.5, units = "in", dpi = 300)
```


# Vertical profile of biomass:
Using the df: output (Sv value per 5m vertical bin), create a plot with depth on Y axis and Sv (or NASC on X)
-This df:output is everything from 10 m from the surface to bottom_deadzone

This is a common plot I see in acoustic papers which plots backscatter (for a 100m by 5m vertical cell) against depth. This should also highlight the main depths at which we find most backscatter. 
- can group by "layer" 

```{r log linear conversions}

# convert from dB to linear
db_to_linear <- function(db){ 10^ (db/10) 
}

# convert from linear to dB
linear_to_db <- function(linear){ 10*log10(linear)
}

# Sv to sv- this doesn't look right! 
Sv_to_sv <- function(Sv){ 10^ (Sv/10) 
}

# sv to Sv
sv_to_Sv <- function(sv){ 10*log10(sv)
}
```
# Depth distribution of backscatter
Need to convert Sv to sv prior to taking mean value and then reconvert it back from sv to Sv for final plot!

```{r depth and backscatter as a density plot}
# summarize mean Sv per year
output$sv= Sv_to_sv(Sv=output$Sv_mean) #create a column that converts Sv to sv

# Summarize by depth bin 
depth_dist <- output |> 
              group_by(Layer_depth_min, Year) |> 
              summarize(sv_mean= mean(sv),
                        NASC_mean=mean(NASC), .groups="drop")
#Note: it is not appropriate to take the straight mean of Sv values! Need to convert to sv (linear) and then re-convert back to log (dB) scale! 
# convert sv back into Sv
depth_dist$Sv_mean= sv_to_Sv(sv=depth_dist$sv_mean) #convert back from sv to Sv (dB)


# Sv mean plot 

ggplot(data = filter(depth_dist, Layer_depth_min>=150 & Layer_depth_min<=525), aes(x=Sv_mean, y=as.factor(Layer_depth_min), group=as.factor(Year), color=as.factor(Year)))+
  geom_line(orientation = "y")+
  scale_color_manual(values = c("2013"="grey86", "2014"="grey75", "2015"="chocolate", "2016"="darkorange", "2017"="grey50", "2018"="grey20"))+
  scale_y_discrete(breaks=c(10, 100,200,300,400,500, 600, 700),labels=c("10","100","200","300","400","500", "600", "700"), limits=rev)+ 
  ylab("Depth (m)")+
  xlab("Mean Sv (dB)")+
  labs(color="Year")+
  ggthemes::theme_few()+
  theme(panel.background = element_blank(),
        legend.key=element_blank())
  #facet_wrap(~Year)  to get a plot per year
ggsave("./plots/analysis 1/depth_dist.pdf")




# NASC mean plot 

ggplot(data = filter(depth_dist, Layer_depth_min>=150 & Layer_depth_min<=525), aes(x=NASC_mean, y=as.factor(Layer_depth_min), group=as.factor(Year), color=as.factor(Year)))+
  geom_line(orientation = "y")+
  scale_color_manual(values = c("2013"="grey86", "2014"="grey75", "2015"="chocolate", "2016"="darkorange", "2017"="grey50", "2018"="grey20"))+
  scale_y_discrete(breaks=c(10, 100,200,300,400,500, 600, 700),labels=c("10","100","200","300","400","500", "600", "700"), limits=rev)+ 
  ylab("Depth (m)")+
  xlab("NASC")+
  labs(color="Year")+
  ggthemes::theme_few()+
  theme(panel.background = element_blank(),
        legend.key=element_blank())
  #facet_wrap(~Year)  to get a plot per year
ggsave("./plots/analysis 1/depth_dist_nasc.pdf")

#rm(depth_dist)
```
Could also use NASC but because this is an integrated value and there are various levels of missing data, MVBS seems like a more appropriate value to use here?! That said, the NASC version of this plot looked better :) NOTE: to create NASC version of this plot, substitute NASC_mean for SV_mean value and replot (second figure above). This version looks way better, but as mentioned I am not sure how this works with integration, so might just ignore using this plot for now...leaving for reference. 

# DATA ANALYSIS

# DISTRIBUTION OF DATA
# examining distribution of data-- Create a qq (qunatile plot) to assess normality of data- each year seperately
```{r qq plot MVBS per year}

# Plot QQ plot of MVBS- per year
ggplot(data=acoustic_regrid, aes(sample=MVBS, group=year, color=year))+
  stat_qq()+
  stat_qq_line()+
  scale_color_brewer(palette = "Blues")+
  theme(panel.background = element_blank(), 
        plot.background = element_blank(), #removes plot background
        legend.key = element_blank()) #removes grey around legend symbols

#ggsave(filename = "./plots/qqplot_nasc_year.jpeg")
```
# QQ plot for all years combined 
Not a great fit of normality since the tails drift below or above our line.
```{r}
ggplot(data=acoustic_regrid, aes(sample=MVBS))+
  stat_qq()+
  stat_qq_line()+
  theme(panel.background = element_blank(), 
        plot.background = element_blank(), #removes plot background
        legend.key = element_blank()) #removes grey around legend symbols
```

NOTE: when I initially analyzed these data, I also ran an ANOVA but I think the Kruskall-wallis is more forgiving of our assumptions and thus more robust

# STATISTICAL TEST:  KRUSKAL WALLIS

The Kruskal Wallis test is similar to the ANOVA, but does not require assumption of normality: "The experimental situation is one where K random samples have been obtained, one from each of k possibly different populations, and we want to test the null hypothesis that all of the populations are identical against the alternative that some of the populations tend to furnish greater observed values than other populations." Conover

From Conover 1999: The following Assumptions are required:
1. All samples are random samples from their respective populations.
2. In addition to independence within each sample, there is mutual independence among the various samples.
3. The measurement scale is at least ordinal
4. Either the k population distribution functions are identical, or else some of the populations tend to yield larger values than other populations do. 

Hypotheses:
H0: all of the K population distribution functions are identical
H1: At least one of the populations tends to yield larger observations than at least one of the other populations
alt H1: The k populations do not all have identical means

# convert year to a factor
Not sure if this is patently required, but helps simplify structure 
```{r}
# first ensure that year is a factor
acoustic_regrid$year <- as.factor(acoustic_regrid$year)
levels(acoustic_regrid$year) #check on order of factor year (all good in sequential order)
```

# Kruskall Wallis test: MVBS and CM between years 
# MANUAL step
```{r MANUAL STEP}

# MANUAL OUTPUT -- save output for grid size

# Kruskal wallis test-- MVBS
kw_mvbs= kruskal.test(MVBS ~ year, data = acoustic_regrid)
kw_mvbs

#MANUAL: save output per grid size
kw_mvbs_25km=kw_mvbs


# Kruskal wallis test--- CM
kw_cm= kruskal.test(cm_m ~ year, data = acoustic_regrid)
kw_cm

#MANUAL: save output per grid size
kw_cm_25km=kw_cm

```
If p-value <0.05 we can conclude that there are significant differences between groups (years). In order to know which pairs of years were different, we must further test with multiple comparisons.

# MUTLIPLE COMPARISONS-- Kruskal Wallis 
Although we now know there are differences between years, we don't know between WHICH years these differences occur. To compare between groups (years) we thus additionally need pairwise comparisons.

Background: "If, and only if the null hypothesis is rejected, we may we use the following procedure to determine which pairs of populations tend to differ" uses rank-sum Conover

NOTE: default value for multiple comparisons is "BH" for Bejamini & Hochberg. see p.adjust for more info. Bonferonni is the most conservative options here so I am starting with that. 

#MANUAL
```{r mutliple comparisons kruskal wallis }
?pairwise.wilcox.test

# multiple comparisons test-- MVBS
kw_mc_mvbs= pairwise.wilcox.test(acoustic_regrid$MVBS, acoustic_regrid$year,
                 p.adjust.method = "bonferroni")
kw_mc_mvbs

# MANUAL: save output per grid cell size
kw_mc_mvbs_25km= kw_mc_mvbs



# multiple comparisons test-- CM
kw_mc_cm= pairwise.wilcox.test(acoustic_regrid$cm_m, acoustic_regrid$year,
                 p.adjust.method = "bonferroni")

# MANUAL: save output per grid cell size
kw_mc_cm_25km= kw_mc_cm

# to see p-values:
format(kw_mc_cm$p.value, scientific = FALSE)


```

# Data for compact letter display (cld) via {rcompanion} to complete output table and {multcompView} for creating the CLD
compact lettering display
Compact letter display allows us to appropraitely color signifiant differences in our data
```{r}

#Take our p.value output from Pairwise.Wilcoxon.Text (ie mutliple comparisons for kruskall wallis)

kw_mc_cm
kw_mc_mvbs

# select for our p-value output- table of P-values for pairwise comparisons
table_cm= kw_mc_cm$p.value
table_mvbs= kw_mc_mvbs$p.value

#convert these tables into "full" tables ie not just NA using packge rcompaniion
kw_mc_cm_full = rcompanion::fullPTable(table_cm)
kw_mc_mvbs_full = rcompanion::fullPTable(table_mvbs)


# calculate CLD
cld_cm= multcompView::multcompLetters(kw_mc_cm_full)
cld_mvbs= multcompView::multcompLetters(kw_mc_mvbs_full)

# display groupings
cld_cm
cld_mvbs


# add these values to our summary_year table
summary_year= summary_year |> 
  mutate(cld_cm=as.vector(cld_cm$Letters), cld_mvbs=as.vector(cld_mvbs$Letters))

#remove intermediary steps
rm(kw_mc_cm_full, kw_mc_mvbs_full, table_cm, table_mvbs)
```

# Add output from multiple comparisons to boxplot

see https://r-graph-gallery.com/84-tukey-test a little complicated
https://statdoe.com/one-way-anova-and-box-plot-in-r/

# Add multipe comparisons letters to boxplot -- MVBS
color blind friendly palette

clrs = c(
"a" = "#E69F00FF",
"b" = "#65B4E9FF",
"c" = "#009E73FF",
"d" = "#F0E442FF",
"e" = "#0072B2FF",
"f" = "#D55E00FF",
"g" = "#CC79A7FF"
)

So if there are only two groups, ex. "a" and "b", just set colors for a and b and # out the remaining options
just remove comma after last color

#MANUAL: adjust color ramp and position of letters within circles :) 
NOTE: I updated the clrs: so blue is cooler years and orange is warmer years. This means it is no longer consistent with other spatial scales, but fine with that :) Exported typical color scheme as well
```{r}

#set up MANUAL color scale for letters
clrs= unique(summary_year$cld_mvbs)
clrs #run this to see what the output is for a given grid size
clrs = c(
"a" = "#65B4E9FF",
"b" = "#E69F00FF"
#"c" = "#009E73FF",
#"d" = "#F0E442FF",
#"be" = "#0072B2FF",
#"e" = "#D55E00FF"
#"g" = "#CC79A7FF"
)
# manually set some color-blind friendly colors and manually update labels depending on unique combinations

# simple box plot of MVBS values- multiple comparison results from KW 
ggplot(data=acoustic_regrid, aes(x=year, y=MVBS))+
  stat_boxplot(geom="errorbar", width=0.25)+ #error bars
  geom_boxplot(data=acoustic_regrid, aes(x=year, y=MVBS), outlier.shape=NA)+ #plot boxplots without outliers since in jitter
  geom_jitter( width=0.10, height=0, alpha=0.3, color="slategrey")+ #add actual data points to our boxplot don't jitter in vertical direction and close toge horiz
  geom_text(data= summary_year, aes(x = year, y = median_MVBS, label = paste0("MVBS: ", median_MVBS)), size = 2.5, vjust = -0.5)+ #label median 
  geom_text(data= summary_year, aes(x = year, y = median_MVBS, label = paste0("n: ", no_grid_cells)), size = 2, vjust = 1.5, color="black")+ #n
  geom_point(data = summary_year, aes(x = year, y = quantile_mvbs+1, label = cld_mvbs, color=cld_mvbs), size=6, alpha=1, show.legend = FALSE)+ # label cld
  geom_text(data = summary_year, aes(x = year, y = quantile_mvbs, label = cld_mvbs), vjust=-2.2, color="black")+ # label significance cl adjust position
  scale_color_manual(values=clrs)+ #use manual color palette defined above 
  xlab("Year")+
  ylab("MVBS (dB)")+
  theme(legend.position = 'none')+
  ggthemes::theme_few()


ggsave(filename=paste0("./plots/analysis 1/boxplot_kw_mc_mvbs_jitter_", grid_size, "_.pdf"), width=7, height=5, units="in")

```
Play around with the position of letters and circles, they shift with each cell size (eye roll)
Also vary when exported
25km: vjust= -2.2
20km: vjust= -1.7
15km: vjust= -1.4
10km: vjust= -1.3
5km: vjust= -1.3
1km: vjust= -1.3

# Same plot but transparent background
for presentations with a black background
```{r}
ggplot(data=acoustic_regrid, aes(x=year, y=MVBS))+
  stat_boxplot(geom="errorbar", width=0.25, color="white")+
  geom_boxplot(data=acoustic_regrid, aes(x=year, y=MVBS), fill=NA, color="white", outlier.shape=NA)+ #plot boxplots without outliers since in jitter
  geom_jitter( width=0.10, height=0, alpha=0.3, color="slategrey")+ #add actual data points to our boxplot don't jitter in vertical
  geom_text(data= summary_year, aes(x = year, y = median_MVBS, label = paste0("MVBS: ", median_MVBS)), size = 2.5, vjust = -0.5, color="white")+ #label median 
  geom_text(data= summary_year, aes(x = year, y = median_MVBS, label = paste0("n: ", no_grid_cells)), size = 2, vjust = 1.5, color="white")+ #n
  geom_point(data = summary_year, aes(x = year, y = quantile_mvbs+1, label = cld_mvbs, color=cld_mvbs), size=6, alpha=1, show.legend = FALSE)+ # label cld
  geom_text(data = summary_year, aes(x = year, y = quantile_mvbs, label = cld_mvbs), vjust=-2.2, color="white")+ # label significance cl
  scale_color_manual(values=clrs)+ #use manual color palette defined above 
  xlab("Year")+
  ylab("MVBS (dB)")+
  theme(legend.position = 'none')+
  ggthemes::theme_few()+
  theme(legend.position = 'none',
        panel.background = element_rect(fill = 'transparent', color="white"),
        plot.background = element_rect(fill='transparent', color="white"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.background = element_rect(fill='transparent'),
        legend.box.background=element_rect(fill = 'transparent'),
        axis.text = element_text(colour="white"),
        axis.line = element_line(color = "white"),
        axis.title = element_text(color="white"))


ggsave(filename=paste0("./plots/analysis 1/boxplot_kw_mc_mvbs_transparent_", grid_size, "_.pdf"), width=7, height=5, units="in", bg="transparent")
# Add multiple comparisons to boxplot -- CM
```

# # Add multipe comparisons letters to boxplot -- CM
```{r}

#set up MANUAL color scale for letters (manually change inputs to match cld output)
clrs= unique(summary_year$cld_cm)
clrs # run this to see unique output per grid size
clrs = c(
"a" = "#009E73FF",
"b" = "#65B4E9FF",
"c" = "#E69F00FF"
#"d" = "#F0E442FF",
#"e" = "#0072B2FF"
#"f" = "#D55E00FF",
#"g" = "#CC79A7FF"
)
# manually set some color-blind freindly colors and manually update labels depending on unique combinations

# simple box plot of MVBS values- multiple comparison results from KW 
ggplot(data=acoustic_regrid, aes(x=year, y=cm_m, color=year))+
  stat_boxplot(geom="errorbar", width=0.25)+
  geom_boxplot(data=acoustic_regrid, aes(x=year, y=cm_m), outlier.shape=NA)+ #plot boxplots without outliers since in jitter
  #scale_color_manual(values = c("2013"="grey20", "2014"="grey20", "2015"="chocolate", "2016"="chocolate", "2017"="grey20", "2018"="grey20"))+
  geom_jitter(width=0.10, height=0, alpha=0.3, color="slategrey")+ #add actual data points to our boxplot
  geom_text(data= summary_year, aes(x = year, y = median_CM, label = paste0("CM: ", median_CM)), size = 2.5, vjust = -0.5, color="black")+ #label median 
  geom_text(data= summary_year, aes(x = year, y = median_CM, label = paste0("n: ", no_grid_cells)), size = 2, vjust = 1.5, color="black")+ #n
  geom_point(data = summary_year, aes(x = year, y = quantile_cm+10, label = cld_cm, color=cld_cm), size=6, alpha=1)+ # label cld
  geom_text(data = summary_year, aes(x = year, y = quantile_cm, label = cld_cm), vjust=2.2, color="black")+ # label significance cld
  scale_color_manual(values=clrs)+ #use manual color palette defined above 
  scale_y_reverse()+
  xlab("Year")+
  ylab("CM (m)")+
  ggthemes::theme_few()+
  theme(legend.position = 'none')
  
ggsave(filename=paste0("./plots/analysis 1/boxplot_kw_mc_cm_jitter_", grid_size, "_.pdf"), width=7, height=5, units="in", bg="transparent")

```
25km: vjust= 2.2
15km: vjust= 2.1
10km: vjust= 2.0
5km: vjust= 2.0
NOTE: also exported with more intuitive color scheme (orginal also exported with underscore original_color_)

# Same plot but transparent background
for presentations with black backgrounds

```{r}
ggplot(data=acoustic_regrid, aes(x=year, y=cm_m, color=year))+
  stat_boxplot(geom="errorbar", width=0.25, color="white")+
  geom_boxplot(data=acoustic_regrid, aes(x=year, y=cm_m), outlier.shape=NA, fill=NA, color="white")+ #plot boxplots without outliers since in jitter
  #scale_color_manual(values = c("2013"="grey20", "2014"="grey20", "2015"="chocolate", "2016"="chocolate", "2017"="grey20", "2018"="grey20"))+
   geom_jitter(width=0.10, height=0, alpha=0.3, color="slategrey")+ #add actual data points to our boxplot
  geom_text(data= summary_year, aes(x = year, y = median_CM, label = paste0("CM: ", median_CM)), size = 2.5, vjust = -0.5, color="white")+ #label median 
  geom_text(data= summary_year, aes(x = year, y = median_CM, label = paste0("n: ", no_grid_cells)), size = 2, vjust = 1.5, color="white")+ #n
  geom_point(data = summary_year, aes(x = year, y = quantile_cm+10, label = cld_cm, color=cld_cm), size=6, alpha=1)+ # label cld
  geom_text(data = summary_year, aes(x = year, y = quantile_cm, label = cld_cm), vjust=1.9, color="white")+ # label significance cld
  scale_color_manual(values=clrs)+ #use manual color palette defined above 
  scale_y_reverse()+
  xlab("Year")+
  ylab("CM (m)")+
  ggthemes::theme_few()+
  theme(legend.position = 'none')+
  theme(legend.position = 'none',
        panel.background = element_rect(fill = 'transparent', color="white"),
        plot.background = element_rect(fill='transparent', color="white"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.background = element_rect(fill='transparent'),
        legend.box.background=element_rect(fill = 'transparent'),
        axis.text = element_text(colour="white"),
        axis.line = element_line(color = "white"),
        axis.title = element_text(color="white"))
  
ggsave(filename=paste0("./plots/analysis 1/boxplot_kw_mc_cm_transparent", grid_size, "_.pdf"), width=7, height=5, units="in")
```


# Now re-run for each of the additional grid cell sizes
1km, 5km, 10km, 15km, 20km, 25km






















