---
title: "Satellite data"
output: html_notebook
---

This code was written by II for the manuscript: https://doi.org/10.1093/icesjms/fsae129
This code is preceded by "Ocean regrid.Rmd" and followed by "Analysis 2 GAM.Rmd"

# Objective of code

Extract information about light from satellite data via ERDDAP (Aqua Modis satellite)


# Background
We did not have CTD light data available for all years of our study. The following code extracts satellite light data for the location of our acoustics tracks

8-day composite in 4km grid cells

All products: https://coastwatch.pfeg.noaa.gov/erddap/search/index.html?page=1&itemsPerPage=1000&searchFor=kd490


#Calculate Z: depth at which light ~ 1% of surface at 490 nm
```{r}

Z= function(per, Kd){-log(per)/Kd
}

# Trial: so if our Kd value was 0.1, the depth at which we get 1% light level is 46m
Z(per=0.01, Kd=0.1)
```
# Load libraries
```{r}
# start by installing packages
library(tidyverse) #data wrangling. possibly plotting via ggplot
library(ncdf4) # for opening and extracting data from netCDF files 
#library(oce) for cmocean color palettes for plotting 
library(sf) #plotting spatial objects
library(rerddap) # for accessing erddap via R
library(rerddapXtracto) # roy's package to extract data along a track (ex. acoustics track)
library(cmocean) #great color palettes

```

### Using {RERDDAP} to extract data directly from ERDDAP servers
References
https://cran.r-project.org/web/packages/rerddap/vignettes/Using_rerddap.html
https://docs.ropensci.org/rerddap/articles/Using_rerddap.html
{xtractomatic} and {rerddapXtracto} used to extract k490 data from our exact acoustics track
https://rmendels.github.io/UsingrerddapXtracto.html

# Select ERDDAP dataset
8-day composite data (to avoid missing day for single day)
https://coastwatch.pfeg.noaa.gov/erddap/griddap/erdMH1kd4908day.html

# rerddapXtracto: to extract light data for acoustic track (8-day composite)
```{r}
# select rerddap dataset
k490_info <- rerddap::info('erdMH1kd4908day') # 8 day composite data

# Create a date column that matches desired format year-month-day

echo_integration_all$month= stringr::str_sub(echo_integration_all$day, "1", "2")
echo_integration_all$day= stringr::str_sub(echo_integration_all$day, "3", "4") #start and end pos

# Make a new column that is a date in the format year-month-day
echo_integration_all= echo_integration_all |> 
  mutate(time=paste0(year, month, day)) |> 
  mutate(time=lubridate::ymd(time))


# use extracto to extract k490 for our survey data! 

k490_track= rerddapXtracto::rxtracto(dataInfo=k490_info, parameter="k490", xcoord=echo_integration_all$Lon_M, ycoord=echo_integration_all$Lat_M, tcoord = echo_integration_all$time) #xlen = 0.1, ylen=0.1 to increase search area but shifted data only use if need didn't seem to add any data 

# note xlen and ylen set to 0.1 which is search for nearest point 0.1 ~ 11km or at the resolution of 4m a little over 2 cells
```

#Clean up output and convert to dataframe-- calculate Z from k490
```{r}
#k490_track[[1]] #k490 mean values 

k490= k490_track$`mean k490` #k490 mean
time=k490_track$`satellite date` # time
lon=k490_track$`requested lon min` # lon
lat=k490_track$`requested lat min` 

k490_track_df= as.data.frame(cbind(k490, time, lon, lat))
rm(k490, time, lon, lat)

# need to make a column for year
k490_track_df= k490_track_df |> 
  mutate(year=lubridate::year(time)) 

k490_track_df$year= as.character(k490_track_df$year) # convert to character to match acoustics_ctd df 

# Convert values to numeric where necessary
k490_track_df$k490 <- as.numeric(k490_track_df$k490)
k490_track_df$lon <- as.numeric(k490_track_df$lon)
k490_track_df$lat <- as.numeric(k490_track_df$lat)


# convert time from character to ymd
# first remove additional information from erddap format

k490_track_df= k490_track_df |> 
  mutate(time_2= stringr::str_sub(time, "1", "10")) |> 
  mutate(time=lubridate::ymd(time_2)) |> 
  dplyr::select(-time_2)

# filter for no na values
k490_track_df= k490_track_df |> 
  filter(!is.na(k490))


#check on str of df
str(k490_track_df)
class(k490_track_df$time)


# finally, convert our kd490 valus from the diffusion coefficient to a 1% light level depth via our function Z
#function(per, Kd){-log(per)/Kd
#}

k490_track_df$Z <- Z(per=0.01, Kd=k490_track_df$k490) # 0.01 is 1%
range(k490_track_df$Z) 
```

# PLOT DATA-- Plot of light levels overlaid acoustic track data 

```{r}
str(k490_track_df)

# plot cover of kd490 data per day 
ggplot()+
  geom_sf(data=states)+ # add a basemap
  coord_sf(xlim=c(-124.5, -121 ), ylim=c(36 ,39))+ #study region
  geom_point(data=echo_integration_all, aes(x=Lon_M, y=Lat_M), color="gray")+
  geom_point(data=k490_track_df, aes(x=lon, y=lat, color=k490))+
  cmocean::scale_color_cmocean(name="turbid", direction=1)+
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        #panel.grid = element_line(colour = "black", linetype = "solid"),
        panel.background = element_blank())+
    facet_wrap(~year)

```
# Compare irradiance between years-- just for reference
```{r}

# summarize mean light between years

k490_years= k490_track_df |> 
  group_by(year) |> 
  summarise(mean_Z=mean(Z), mean_k490=mean(k490), sd_k490=sd(k490), median_z=median(Z))

# simple plot of light between years 
ggplot(data= k490_years)+
  geom_point(aes(x=year, y=mean_k490))+
  xlab("Year")+
  ylab("Mean K490 (satellite)")+
  theme(panel.background = element_blank(),
        plot.background = element_blank(),
        panel.border = element_rect(fill="transparent", color="black"))


# simple plot of Z between years 
ggplot(data= k490_years, aes(x=year, y=mean_Z))+
  geom_line()+
  #geom_point(aes(x=year, y=mean_Z))+
  xlab("Year")+
  ylab("Mean K490 (satellite)")+
  theme(panel.background = element_blank(),
        plot.background = element_blank(),
        panel.border = element_rect(fill="transparent", color="black"))



# boxplot of k490 between years 
ggplot(data=k490_track_df, aes(x=year, y=k490))+
  geom_boxplot()+
  ggthemes::theme_few()

# boxplot of light between years - with median values 
ggplot(data=k490_track_df, aes(x=year, y=Z))+
  geom_boxplot()+
  stat_boxplot(geom="errorbar", width=0.25)+
  scale_y_reverse()+
  geom_text(data=k490_years, aes(x=year, y=median_z, label=paste0("Z [m] =",round(median_z, 2))), vjust=2, size=2.5)+
  xlab("Year")+
  ylab("Z [m]")+
  ggthemes::theme_few()


```

# PLOT of depth at which light is 1% of surface
```{r}
# plot 1% light level (based on kd490)
ggplot()+
  geom_sf(data=states)+ # add a basemap
  coord_sf(xlim=c(-124.5, -121 ), ylim=c(36 ,39))+ #study region
  geom_point(data=echo_integration_all, aes(x=Lon_M, y=Lat_M), color="gray")+ # our acoustic tracks for location info
  geom_point(data=k490_track_df, aes(x=lon, y=lat, color=Z))+  # Z is the depth at which light is 1% of surface
  cmocean::scale_color_cmocean(name="deep", direction=1)+
  scale_x_continuous(breaks = round(acoustic_regrid$lon_grid_low,1), minor_breaks = NULL)+ # grid lines
  scale_y_continuous(breaks= round(acoustic_regrid$lat_grid_hi,1), minor_breaks = NULL)+ # grid lines 
  theme(panel.grid = element_line(colour = "black", linetype = "solid"),
        panel.background = element_blank())+
  facet_wrap(~year)
  
ggsave("./plots/light_tracks.pdf")
```

# Regrid SATELLITE data - LIGHT 
```{r satellite derived light data from MODIS satellite data}

# check resolution of raster layer : should be 25000 and 25000
res(r)

# FOR LOOP: For each unique year of CTD data (and acoustics)
yr= unique(k490_track_df$year)

# Create df to store output in
light <- data.frame()

for(i in 1:length(yr)){
  #filter for given year
  light_yr <- k490_track_df |> 
             filter(year==yr[i]) #select for one year at a time
             
  # convert to sf object
  light_yr_sf <- sf::st_as_sf(x=light_yr, coords=c('lon','lat'), remove = FALSE, crs=4326) #sf object with lat lon coord system
  light_yr_sf <- sf::st_transform(light_yr_sf, crs=32610)# Convert to projected coordinate system (UTM Zone 10N, datum: WGS84) to match raster r
  
  # rasterize our CTD data to our acoustics grid (r) created previously (of distance dist=)
  x_yr<- raster::rasterize(x=light_yr_sf, y=r, field=light_yr_sf$Z, fun=function(x,...) c(length(x), mean(x, na.rm=TRUE))) #MANUAL 
  #this returns the mean value at 150m per cell. In those cases where there were only one CTD, this should just be that single value
  
# convert raster output to dataframe object
x_yr_df<- raster::as.data.frame(x=x_yr, xy=TRUE, centroids=TRUE, na.rm=TRUE) 
x_yr_df <- x_yr_df |> 
  rename(lon=x, lat=y, count_sat_pts=layer.1, Z=layer.2) |> #rename col names based on their true values: length and identity (value at 150m)
  mutate(year=yr[i]) #create col for year for when we merge later
  

# store output to df
light <- rbind(light, x_yr_df) #MANUAL

}


# note this output ctd_temp_cm is in UTM Zone 10N- need to convert back to WGS 84: LAT LON coordinate reference system -- # MANUAL
light_sf <- st_as_sf(x=light, coords=c('lon','lat'), remove = FALSE, crs=32610) # convert to SF object with UTM Zone 10N
light_sf <- st_transform(light_sf, crs=4326)# Convert coordinate system from utm zone 10N back to WGS 84 (Lon Lat)

# break geometry column into two columns for lon and lat

  light_sf <- light_sf |> 
              dplyr::mutate(lon = sf::st_coordinates(light_sf)[,1],
              lat = sf::st_coordinates(light_sf)[,2]) |> 
              dplyr::select(-geometry)

                
# convert from sf back to  dataframe
light <- as.data.frame(st_drop_geometry(light_sf))

#remove intermediary dfs
rm(light_sf) #no longer need this sf since we converted to df
rm(light_yr, light_yr_sf, x_yr, x_yr_df) #output from for loop

```

# Now join our re-gridded light data to our existing oceanographic variables

```{r}
# join light to acoustics_ctd data
#first convert from character to numeric 
light$year <- as.numeric(light$year)
# join to existing oceanographic variables 
acoustics_ctd= left_join(acoustics_ctd, light, by=c("year", "lat", "lon")) #Join density at 150m

rm(light, k490_track_df, k490_track)
```

# Remove rows with missing light info
Now df: acoustics_ctd: ALL oceanographic variables linked to acoustics data

```{r}

acoustics_ctd= acoustics_ctd |> 
                dplyr::filter(!is.na(Z))

```


# Next code....

Move to Analysis 2 GAM.Rmd 





























