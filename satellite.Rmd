---
title: "Satellite data"
output: html_notebook
---

# Objective of code

Extract information about light from satellite data via ERDDAP (Aqua Modis satellite)


# Background
We did not have CTD light data available for all years of our study, and so the following code extracts satellite light data for the location of our acoustics tracks

8-day composite in 4km grid cells

All products: https://coastwatch.pfeg.noaa.gov/erddap/search/index.html?page=1&itemsPerPage=1000&searchFor=kd490


#Calculate Z: depth at which light ~ 1% of surface at 490 nm
```{r}

Z= function(per, Kd){-log(per)/Kd
}

# Trial: so if our Kd value was 0.1, the depth at which we get 1% light level is 46m
Z(per=0.01, Kd=0.1)
```
# Load libraries
```{r}
# start by installing packages
library(tidyverse) #data wrangling. possibly plotting via ggplot
library(ncdf4) # for opening and extracting data from netCDF files 
#library(oce) for cmocean color palettes for plotting 
library(sf) #plotting spatial objects
library(rerddap) # for accessing erddap via R
library(rerddapXtracto) # roy's package to extract data along a track (ex. acoustics track)
library(cmocean) #great color palettes

```

### Using {RERDDAP} to extract data directly from ERDDAP servers
References
https://cran.r-project.org/web/packages/rerddap/vignettes/Using_rerddap.html
https://docs.ropensci.org/rerddap/articles/Using_rerddap.html
{xtractomatic} and {rerddapXtracto} used to extract k490 data from our exact acoustics track
https://rmendels.github.io/UsingrerddapXtracto.html

# Select ERDDAP dataset
8-day composite data (to avoid missing day for single day)
https://coastwatch.pfeg.noaa.gov/erddap/griddap/erdMH1kd4908day.html

# rerddapXtracto: to extract light data for acoustic track (8-day composite)
```{r}
# select rerddap dataset
k490_info <- rerddap::info('erdMH1kd4908day') # 8 day composite data

# Create a date column that matches desired format year-month-day

echo_integration_all$month= stringr::str_sub(echo_integration_all$day, "1", "2")
echo_integration_all$day= stringr::str_sub(echo_integration_all$day, "3", "4") #start and end pos

# Make a new column that is a date in the format year-month-day
echo_integration_all= echo_integration_all |> 
  mutate(time=paste0(year, month, day)) |> 
  mutate(time=lubridate::ymd(time))


# use extracto to extract k490 for our survey data! 

k490_track= rerddapXtracto::rxtracto(dataInfo=k490_info, parameter="k490", xcoord=echo_integration_all$Lon_M, ycoord=echo_integration_all$Lat_M, tcoord = echo_integration_all$time) #xlen = 0.1, ylen=0.1 to increase search area but shifted data only use if need didn't seem to add any data 

# note xlen and ylen set to 0.1 which is search for nearest point 0.1 ~ 11km or at the resolution of 4m a little over 2 cells
```

#Clean up output and convert to dataframe-- calculate Z from k490
```{r}
#k490_track[[1]] #k490 mean values 

k490= k490_track$`mean k490` #k490 mean
time=k490_track$`satellite date` # time
lon=k490_track$`requested lon min` # lon
lat=k490_track$`requested lat min` # lat not could be either min or max it looks like bc same

k490_track_df= as.data.frame(cbind(k490, time, lon, lat))
rm(k490, time, lon, lat)

# need to make a column for year
k490_track_df= k490_track_df |> 
  mutate(year=lubridate::year(time)) 

k490_track_df$year= as.character(k490_track_df$year) # convert to character to match acoustics_ctd df 

# Convert values to numeric where necessary
k490_track_df$k490 <- as.numeric(k490_track_df$k490)
k490_track_df$lon <- as.numeric(k490_track_df$lon)
k490_track_df$lat <- as.numeric(k490_track_df$lat)


# convert time from character to ymd
# first remove additional information from erddap format

k490_track_df= k490_track_df |> 
  mutate(time_2= stringr::str_sub(time, "1", "10")) |> 
  mutate(time=lubridate::ymd(time_2)) |> 
  dplyr::select(-time_2)

# filter for no na values
k490_track_df= k490_track_df |> 
  filter(!is.na(k490))


#check on str of df
str(k490_track_df)
class(k490_track_df$time)


# finally, convert our kd490 valus from the diffusion corefficient to a 1% light level depth via our function Z
#function(per, Kd){-log(per)/Kd
#}

k490_track_df$Z <- Z(per=0.01, Kd=k490_track_df$k490) # 0.01 is 1%
range(k490_track_df$Z) # note that this range goes from 1.2 to 90 m?!! I would have thought it was much deeper than this, so I may have to think about what this means
```

# PLOT DATA-- Plot of light levels overlaid acoustic track data 

```{r}
str(k490_track_df)

# plot cover of kd490 data per day 
ggplot()+
  geom_sf(data=states)+ # add a basemap
  coord_sf(xlim=c(-124.5, -121 ), ylim=c(36 ,39))+ #study region
  geom_point(data=echo_integration_all, aes(x=Lon_M, y=Lat_M), color="gray")+
  geom_point(data=k490_track_df, aes(x=lon, y=lat, color=k490))+
  cmocean::scale_color_cmocean(name="turbid", direction=1)+
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        #panel.grid = element_line(colour = "black", linetype = "solid"),
        panel.background = element_blank())+
    facet_wrap(~year)

```
# Compare irradiance between years-- Ignore below, but leaving for ref
```{r}

# summarize mean light between years

k490_years= k490_track_df |> 
  group_by(year) |> 
  summarise(mean_Z=mean(Z), mean_k490=mean(k490), sd_k490=sd(k490), median_z=median(Z))

# simple plot of light between years 
ggplot(data= k490_years)+
  geom_point(aes(x=year, y=mean_k490))+
  xlab("Year")+
  ylab("Mean K490 (satellite)")+
  theme(panel.background = element_blank(),
        plot.background = element_blank(),
        panel.border = element_rect(fill="transparent", color="black"))


# simple plot of Z between years 
ggplot(data= k490_years, aes(x=year, y=mean_Z))+
  geom_line()+
  #geom_point(aes(x=year, y=mean_Z))+
  xlab("Year")+
  ylab("Mean K490 (satellite)")+
  theme(panel.background = element_blank(),
        plot.background = element_blank(),
        panel.border = element_rect(fill="transparent", color="black"))



# boxplot of k490 between years 
ggplot(data=k490_track_df, aes(x=year, y=k490))+
  geom_boxplot()+
  ggthemes::theme_few()

# boxplot of light between years - with median values 
ggplot(data=k490_track_df, aes(x=year, y=Z))+
  geom_boxplot()+
  stat_boxplot(geom="errorbar", width=0.25)+
  scale_y_reverse()+
  geom_text(data=k490_years, aes(x=year, y=median_z, label=paste0("Z [m] =",round(median_z, 2))), vjust=2, size=2.5)+
  xlab("Year")+
  ylab("Z [m]")+
  ggthemes::theme_few()


```

# PLOT of depth at which light is 1% of surface
```{r}
# plot 1% light level (based on kd490)
ggplot()+
  geom_sf(data=states)+ # add a basemap
  coord_sf(xlim=c(-124.5, -121 ), ylim=c(36 ,39))+ #study region
  geom_point(data=echo_integration_all, aes(x=Lon_M, y=Lat_M), color="gray")+ # our acoustic tracks for location info
  geom_point(data=k490_track_df, aes(x=lon, y=lat, color=Z))+  # Z is the depth at which light is 1% of surface
  cmocean::scale_color_cmocean(name="deep", direction=1)+
  scale_x_continuous(breaks = round(acoustic_regrid$lon_grid_low,1), minor_breaks = NULL)+ # grid lines
  scale_y_continuous(breaks= round(acoustic_regrid$lat_grid_hi,1), minor_breaks = NULL)+ # grid lines 
  theme(panel.grid = element_line(colour = "black", linetype = "solid"),
        panel.background = element_blank())+
  facet_wrap(~year)
  
ggsave("./plots/light_tracks.pdf")
```
# Regrid these depth at which light = 1% values to our grid....
This is code I am stealing and updating from my own previous code Ocean regrid.Rmd

# Regrid SATELLITE data - LIGHT 
```{r satellite derived light data from MODIS satellite data}

# check resolution of raster layer : should be 25000 and 25000
res(r)

# ensure the grids from acosutics_regrid are appropriate for this size (ex. 20km)
#acoustics_regrid= acoustics_regrid_25km #only do once or will overwrite


# FOR LOOP: For each unique year of CTD data (and acoustics)
yr= unique(k490_track_df$year)

# Create df to store output in
light <- data.frame()

for(i in 1:length(yr)){
  #filter for given year
  light_yr <- k490_track_df |> 
             filter(year==yr[i]) #select for one year at a time
             
  # convert to sf object
  light_yr_sf <- sf::st_as_sf(x=light_yr, coords=c('lon','lat'), remove = FALSE, crs=4326) #sf object with lat lon coord system
  light_yr_sf <- sf::st_transform(light_yr_sf, crs=32610)# Convert to projected coordinate system (UTM Zone 10N, datum: WGS84) to match raster r
  
  # rasterize our CTD data to our acoustics grid (r) created previously (of distance dist=)
  x_yr<- raster::rasterize(x=light_yr_sf, y=r, field=light_yr_sf$Z, fun=function(x,...) c(length(x), mean(x, na.rm=TRUE))) #MANUAL 
  #this returns the mean value at 150m per cell. In those cases where there were only one CTD, this should just be that single value
  
# convert raster output to dataframe object
x_yr_df<- raster::as.data.frame(x=x_yr, xy=TRUE, centroids=TRUE, na.rm=TRUE) 
x_yr_df <- x_yr_df |> 
  rename(lon=x, lat=y, count_sat_pts=layer.1, Z=layer.2) |> #rename col names based on their true values: length and identity (value at 150m)
  mutate(year=yr[i]) #create col for year for when we merge later
  

# store output to df
light <- rbind(light, x_yr_df) #MANUAL

}


# note this output ctd_temp_cm is in UTM Zone 10N- need to convert back to WGS 84: LAT LON coordinate reference system -- # MANUAL
light_sf <- st_as_sf(x=light, coords=c('lon','lat'), remove = FALSE, crs=32610) # convert to SF object with UTM Zone 10N
light_sf <- st_transform(light_sf, crs=4326)# Convert coordinate system from utm zone 10N back to WGS 84 (Lon Lat)

# break geometry column into two columns for lon and lat

  light_sf <- light_sf |> 
              dplyr::mutate(lon = sf::st_coordinates(light_sf)[,1],
              lat = sf::st_coordinates(light_sf)[,2]) |> 
              dplyr::select(-geometry)

                
# convert from sf back to  dataframe
light <- as.data.frame(st_drop_geometry(light_sf))

#remove intermediary dfs
rm(light_sf) #no longer need this sf since we converted to df
rm(light_yr, light_yr_sf, x_yr, x_yr_df) #output from for loop

```

# Now join our re-gridded light data to our existing oceanographic variables

```{r}
# join light to acoustics_ctd data
#first convert from character to numeric 
light$year <- as.numeric(light$year)
# join to existing oceanographic variables 
acoustics_ctd= left_join(acoustics_ctd, light, by=c("year", "lat", "lon")) #Join density at 150m

rm(light, k490_track_df, k490_track)
```

# Remove rows with missing light info
Now df: acoustics_ctd: ALL oceanographic variables linked to acoustics data

```{r}

acoustics_ctd= acoustics_ctd |> 
                dplyr::filter(!is.na(Z))

```

Total of 86 cells that have acoustics data, CTD data and satellite light data

# Next
.....




# TO address reviewer comment 
At a minimum, the authors need to use these observations to see how well Aquamodis data reflected water column light penetration in years that had both datasets...

#calculate the depth at which PAR sensor reached 0?

```{r}

# PER CTD CAST, depth at which light = 1% value at 2m 
ctd_euphoic_light= ctd_deep_data_core |>
  select(year, CTD_INDEX, CTD_DEPTH, IRRAD) |> 
  filter(!is.na(IRRAD)) |> 
  filter(CTD_DEPTH==2) |> # considering this "surface" conditions
  mutate(light_2m=IRRAD) |> # light at "surface"
  mutate(light_1_per_2m=light_2m*0.01) |> # light that is 1% of light at "surface"
  select(-IRRAD, -CTD_DEPTH)

# Depth at which light is == 1% of 2 m
# calculate distance from each IRRAD value to each value and then find minimum value

light= ctd_deep_data_core |> 
  select(year, CTD_INDEX, CTD_DEPTH, IRRAD) |> 
  filter(!is.na(IRRAD))
  
# cbind to add euphoic depth value 
light=left_join(light, ctd_euphoic_light, by=c("year", "CTD_INDEX"))


#filter instead of summarize
light_min= light |> 
  filter(!is.na(light_2m)) |> # ensure there was a value for light at 2m >0
  filter(light_2m>0) |> 
  group_by(year, CTD_INDEX) |> # for each year and ctd cast
  filter(dist==min(abs(dist))) # return the row when distance is at a minimum (ie closest value of IRAD to 1% of surface irrad)

# mean "euphotic" depth per year
light_min_yr=light_min |> 
  group_by(year) |> 
  summarise(mean_euphotic_depth=mean(CTD_DEPTH))


```

# ADD PAR data to our satellite data

Adding these values to our boxplots 

```{r}

# Calculate median values for CTD data
ctd_years= light_min |> 
  group_by(year) |> 
  summarise(mean_Z=mean(CTD_DEPTH), sd_Z=sd(CTD_DEPTH), median_Z=median(CTD_DEPTH))

ggplot()+ #plot of satellite data, Z (depth at which light= 1% surface irradiance)
  geom_boxplot(data=k490_track_df, aes(x=year, y=Z))+ # satellite data
  #geom_boxplot(data=light_min, aes(x=factor(year), y=CTD_DEPTH), color="orange", alpha=0.25)+
  stat_boxplot(geom="errorbar", width=0.25)+
  scale_y_reverse()+
  geom_text(data=k490_years, aes(x=year, y=median_z, label=paste0("Z [m] =",round(median_z, 2))), vjust=2, size=2.5)+
  geom_point(data=light_min, aes(x=factor(year), y=CTD_DEPTH), color="chocolate", alpha=0.75, size=2)+
  geom_point(data=ctd_years, aes(x=factor(year), y=mean_Z), size=5, color="chocolate", alpha=0.5)+
  geom_point(data=ctd_years, aes(x=factor(year), y=median_Z), size=5, color="chocolate", alpha=0.5)+
  geom_label(data=ctd_years, aes(x=factor(year), y=mean_Z, label=paste0("Mean Z [m] =",round(mean_Z, 2))),  size=2.7, color="chocolate")+
  geom_label(data=ctd_years, aes(x=factor(year), y=median_Z, label=paste0("Median Z [m] =",round(median_Z, 2))),  size=2.7, color="chocolate")+
  xlab("Year")+
  ylab("Z [m]")+
  ggthemes::theme_few()

ggsave("./plots/par_satellite.pdf")
```

# Calculate annual profiles 
```{r}
# ANNUAL AVERAGES 

mean_par_profiles= ctd_deep_data_core |> 
  group_by(year, CTD_DEPTH) |> 
  summarise(mean_irrad=mean(IRRAD), .groups = "drop") |> 
  filter(!is.na(mean_irrad))

unique(mean_par_profiles$year)


# Calculate depth at which irradiance equals zero?
mean_par_profiles |> 
  group_by(year) |> 
  filter(mean_irrad==0) |> 
  slice(1) #first record where equals zero 

# calculate depth at which irradiance equals 1% of surface value



mean_par_profiles$mean_irrad[min(which(mean_par_profiles$mean_irrad==0.00))]
```

# return depth when ligth reaches closest value to 1% of light at 2m 
light |> 
  filter(!is.na(light_2m)) |> # ensure we had a value for light at the "surface"
  group_by(year, CTD_INDEX) |>  #for each year and ctd cast within a year
  summarise(p=nth(IRRAD, which.min(abs(IRRAD-light_1_per_2m)))) #return the smallest distance from Irradiance value to our targeted irradiance value





# PLOT mean profile 
 
```{r}

ggplot()+
    geom_line(data=mean_par_profiles, aes(y=CTD_DEPTH, x= mean_irrad), color="grey", linewidth=1.5, orientation="y")+ #line
    geom_point(data=mean_par_profiles, aes(y=CTD_DEPTH, x= mean_irrad), color="sienna3", size=2, alpha=0.4)+ #plot individual points above
  geom_text(data=mean_par_profiles, aes(y=CTD_DEPTH, x=mean_irrad, label=round(mean_irrad, 2)), hjust=-1, size=2)+
    scale_y_reverse(expand=c(0,0), limits=c(100,0))+ #remove extra space so plots begin at the surface
    xlab("par")+
    ylab("Depth (m)")+
    ggtitle("Mean profile of PAR")+ # create a title for CTD station year and CTD cast
  geom_vline(xintercept = 0, linetype="dashed", color="darkgrey")+ #simple line demarking mesopelagic depths
  theme(panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background = element_blank(),
        panel.border = element_rect(colour="black", fill=NA, linewidth =2),
        legend.key = element_rect(fill=NA))+
  facet_wrap(~year)

```
































